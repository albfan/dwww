#!/usr/bin/perl
#
# dwww-build -- build HTML pages for dwww
#
# Part of the dwww package.  Written by Lars Wirzenius.
# Rewritten in perl by Robert Luberda <robert@debian.org> on Sep, 2003.
# 
# "@(#)dwww:$Id: dwww-build,v 1.40 2003/09/06 09:31:16 robert Exp $"

use strict; 

use File::Glob ':glob';
use File::Path;
use File::Temp qw/tempfile tempdir/;
use IO::Handle;
use Debian::Dwww::Utils;
use Debian::Dwww::Initialize;

my $conf = &DwwwInitialize("/etc/dwww/dwww.conf");

my $dwww_lib_dir  	= "/usr/share/dwww";
my $template_mbs_start 	= "$dwww_lib_dir/man-in-section.start";
my $template_mbs_end  	= "$dwww_lib_dir/man-in-section.end";
my $template_mbn_start 	= "$dwww_lib_dir/man-begins-with.start";
my $template_mbn_end   	= "$dwww_lib_dir/man-begins-with.end";
my $template_midx_start	= "$dwww_lib_dir/man-index.start";
my $template_midx_end   = "$dwww_lib_dir/man-index.end";
my $template_index_main = "$dwww_lib_dir/dwww.template";


my $verbose = "no";
if ( "x$ARGV[0]" eq "x--verbose" ) {
	$verbose="yes";
	shift @ARGV;
}
my ($tgt, $tgttmp) = undef; 

if (($#ARGV < 0) or  ("x$ARGV[0]" eq "x--default" )) {
	$tgt=$conf->{'DWWW_HTMLDIR'};
} else {
	$tgt="$ARGV[0]";
}
my $tgtupdir = $tgt;
$tgtupdir =~ s|/[^/]+/*$||;

umask 077;
$tgttmp  = tempdir('dwww-build.XXXXXX', DIR => "$tgtupdir", CLEANUP => 1);

my $manlist_fh = tempfile('manlist.XXXXX', DIR => "$tgttmp", UNLINK => 0);
undef $tgtupdir;

my $sepr = " // "; #  manlist file output separator

my $manurl ="/cgi-bin/dwww?type=man&amp;location=";

umask 022;

my @manpages = ();
my $sections = {};
my $letters  = {};

$tgttmp = "$tgttmp/data/";
&mkpath("$tgttmp") or die "Can't create temporary directory: $tgttmp";
&mkpath("$tgttmp/man") or die "Can't create temporary directory: $tgttmp";
&mkpath("$tgttmp/menu") or die "Can't create temporary directory: $tgttmp";

sub debug() {
	local $_ = shift;
	print STDERR "$_\n";
}

sub realpath() {
	local $_ = shift;
}


sub GetSectionDescription() {
	my $section = shift;
	my $desc="";

	if ($section eq "1")           { $desc="User commands"; }
	elsif ($section eq "1L")       { $desc="User commands"; }
	elsif ($section eq "1bind")    { $desc="DNS tools"; }
	elsif ($section eq "1db")      { $desc="Berkeley database routines"; }
	elsif ($section eq "1emacs21") { $desc="Emacs 21"; }
	elsif ($section eq "1fun")     { $desc="Funny man pages"; }
	elsif ($section eq "1l")       { $desc="User commands"; }
	elsif ($section eq "1m")       { $desc="ncurses - terminfo utilities"; }
	elsif ($section eq "1mh")      { $desc="mh (a mail user agent)"; }
	elsif ($section eq "1nas")     { $desc="Network Audio System programs"; }
	elsif ($section eq "1netpbm")  { $desc="netpbm (graphics tools)"; }
	elsif ($section eq "1p")       { $desc="Perl"; }
	elsif ($section eq "1ssl")     { $desc="SSL programs"; }
	elsif ($section eq "1vga")     { $desc="Svgalib programs"; }
	elsif ($section eq "1x")       { $desc="X Window System programs"; }
	elsif ($section eq "2")        { $desc="System calls"; }
	elsif ($section eq "2fun")     { $desc="Funny man pages"; }
	elsif ($section eq "3")        { $desc="Library functions"; }
	elsif ($section eq "3bind")    { $desc="Internet name resolution (DNS) routines"; }
	elsif ($section eq "3curses")  { $desc="ncurses - curses routines"; }
	elsif ($section eq "3db")      { $desc="Berkeley db database routines"; }
	elsif ($section eq "3form")    { $desc="SVR4 compatible screen forms - ncurses"; }
	elsif ($section eq "3fun")     { $desc="Funny man pages"; }
	elsif ($section eq "3gii")     { $desc="General Input Interface library"; }
	elsif ($section eq "3ggi")     { $desc="General Graphics Interface library"; }
	elsif ($section eq "3gdbm")    { $desc="GNU dbm database routines"; }
	elsif ($section eq "3menu")    { $desc="ncurses - SVR4 compatible screen menus"; }
	elsif ($section eq "3mm")      { $desc="msql database routines"; }
	elsif ($section eq "3nas")     { $desc="Network Audio System library"; }
	elsif ($section eq "3ncurses") { $desc="ncurses (terminal screen painting)"; }
	elsif ($section eq "3netpbm")  { $desc="netpbm graphics library"; }
	elsif ($section eq "3paper")   { $desc="paper handling library"; }
	elsif ($section eq "3pm")      { $desc="Perl modules"; }
	elsif ($section eq "3perl")    { $desc="Perl modules"; }
	elsif ($section eq "3pub")     { $desc="Lars Wirzenius' publib routines"; }
	elsif ($section eq "3qt")      { $desc="Trolltech's QT library "; }
	elsif ($section eq "3readline") { $desc="GNU readline prompt routine"; }
	elsif ($section eq "3ssl")     { $desc="SSL library"; }
	elsif ($section eq "3t")       { $desc="libtiff graphics library"; }
	elsif ($section eq "3tcl")     { $desc="Tcl (Tool Command Language) library"; }
	elsif ($section eq "3tclrl")   { $desc="GNU readline for Tcl library"; }
	elsif ($section eq "3tclx")    { $desc="TclX (Extended Tcl) library"; }
	elsif ($section eq "3tcsh")    { $desc="TENEX C Shell (tcsh)"; }
	elsif ($section eq "3thr")     { $desc="pthreads library"; }
	elsif ($section eq "3tix")     { $desc="Tix widget library for Tk"; }
	elsif ($section eq "3tk")      { $desc="Tk widget library"; }
	elsif ($section eq "3tnm")     { $desc="Tcl shell including the Tnm extensions"; }
	elsif ($section eq "3vga")     { $desc="Svgalib library"; }
	elsif ($section eq "3x")       { $desc="X Window System library"; }
	elsif ($section eq "4")        { $desc="Device files"; }
	elsif ($section eq "4x")       { $desc="X Window System"; }
	elsif ($section eq "5")        { $desc="File formats"; }
	elsif ($section eq "5L")       { $desc="File formats"; }
	elsif ($section eq "5bind")    { $desc="DNS"; }
	elsif ($section eq "5fun")     { $desc="Funny man pages"; }
	elsif ($section eq "5mh")      { $desc="mh (mail user agent)"; }
	elsif ($section eq "5mm")      { $desc="msql database"; }
	elsif ($section eq "5nas")     { $desc="Network Audio System"; }
	elsif ($section eq "5snmp")    { $desc="Net-SNMP library"; }
	elsif ($section eq "5ssl")     { $desc="SSL library"; }
	elsif ($section eq "5vga")     { $desc="Svgalib library"; }
	elsif ($section eq "5x")       { $desc="X Window System file formats"; }
	elsif ($section eq "6")        { $desc="Games"; }
	elsif ($section eq "6fun")     { $desc="Funny man pages"; }
	elsif ($section eq "6vga")     { $desc="Svgalib games"; }
	elsif ($section eq "6x")       { $desc="X Window System games"; }
	elsif ($section eq "7")        { $desc="Miscellaneous"; }
	elsif ($section eq "7bind")    { $desc="DNS terms"; }
	elsif ($section eq "7gcc")     { $desc="GNU C compiler library"; }
	elsif ($section eq "7gii")     { $desc="General Input Interface library"; }
	elsif ($section eq "7ggi")     { $desc="General Graphics Interface library"; }
	elsif ($section eq "7ssl")     { $desc="SSL library"; }
	elsif ($section eq "7vga")     { $desc="Svgalib library"; }
	elsif ($section eq "7x")       { $desc="X Window System"; }
	elsif ($section eq "8")        { $desc="System administration commands"; }
	elsif ($section eq "8bind")    { $desc="DNS commands"; }
	elsif ($section eq "8fun")     { $desc="Funny man pages"; }
	elsif ($section eq "8mh")      { $desc="mh (mail user agent)"; }
	elsif ($section eq "8vga")     { $desc="Svgalib library"; }
	elsif ($section eq "9")        { $desc="Linux kernel functions"; }
	elsif ($section eq "9gii")     { $desc="General Input Interface library"; }
	elsif ($section eq "l")        { $desc="Local man pages"; }
	return $desc;
}

sub GetSectionDescriptionInBrakes() {
	my $section = shift;
	my $desc=&GetSectionDescription($section);

	my $desc = "($desc)" unless $desc eq "";
	return $desc;
}

	

# Encodes given $name to be used as a file name or a href name
sub FileEncode() {
	my ($type, $name) = @_;
	$name = &URLEncode($name);
	$name =~ s/_/%5f/g;
	$name =~ s/%/_/g;

	return $type . $name;
}

sub GetIndex() {
	my ($type, $vars) = @_;
	my $ret = '';
	my @list = ();
	my $l = 0;
	my $max_l = 65;
	
	foreach my $i ( sort keys %$vars ) {
		$l += length($i) + 3;
		if ($l > $max_l) {
			$ret .= join (' | ', @list) . "<BR>\n";
			@list 	= ();
			$l	= length($i) + 3;
		}
		push(@list, '<A href="#' . &FileEncode($type, $i) . '">' . &HTMLEncode($i) . '</A>');
	}
	$ret .= join (' | ', @list) . "\n" unless $#list < 0;
	return $ret;
}

	

#
# Find all manual page files.
#
sub find_man() {
	my @manpath = ();
	my @manpages = ();
	my @mantmp  = ();

	@manpath = split (/:/ , `manpath -q`);
	
	foreach my $i (@manpath) {
		chomp $i;
		next if ( "$i" eq "" );
		next unless ( -d "$i" );
		$i = &realpath($i);
		next if ( "$i" eq "");
		push(@mantmp, &bsd_glob("$i/man*/*", GLOB_MARK|GLOB_NOSORT));
	}

	foreach my $index (0 .. $#mantmp) {
		$_ = $mantmp[$index];
		next unless (-f $_);
		s/\.(gz|Z|bz2)$//;
		next unless (m;^.*man([1-9nl])/([^/])([^/]*)\.(\1[^./]*)$;);
		push(@manpages, join( $sepr,  lc($4), uc($2), "$2$3",   &URLEncode($mantmp[$index])));
		
	};
	@mantmp   = undef;
	@manpages = sort { uc($a) cmp uc($b) } @manpages;
	seek ($manlist_fh, 0, 0);
	foreach (@manpages) {
		print $manlist_fh $_ . "\n";
	}
	$manlist_fh -> flush();
}


#
# Output a list of sections.
#
sub find_sections_and_letters() {
	
	seek ($manlist_fh, 0, 0);
	while (<$manlist_fh>){
		chomp;
		my ($section, $letter,  undef,  $path) = split ($sepr, $_, 4);
		$sections->{$section}->{$letter} = 1;
		$letters->{$letter}->{$section} = 1;
	}
}

# 
# Build lists of manual pages according to first letter.
###
sub man_by_name() {
	my $type = 'n';

	foreach my $letter ( keys( %$letters ) ) {
		open M, ">$tgttmp/man/" . &FileEncode($type, $letter) . ".html";
		print M &TemplateFile($template_mbn_start, 
			 	    { 'TITLE' => $conf->{'DWWW_TITLE'},
				      'LETTER' => &HTMLEncode($letter),
				      'HREFLETTER' => &FileEncode($type, $letter),
				      'SECTIONS' => &GetIndex('s', $letters->{$letter})
				    });
		close M;
	}

	my %lastsections = ();
	my %tables	 = ();	
	my $lastletter   = '';

	seek ($manlist_fh, 0, 0);
	while (<$manlist_fh>) {
		chomp();
		my ($section, $letter, $name, $file) = split ($sepr, $_, 4);
		if ($lastletter ne $letter) {
			if ($lastletter ne '') {
				&EndTable(\*M, $tables{$lastletter});
				close M;
			}
			open M, ">>$tgttmp/man/" . &FileEncode($type, $letter) . ".html";
			$lastletter = $letter;
		}
		if ((not exists $lastsections{$letter}) or 
		    ($lastsections{$letter} ne $section)) {
			my $capt='<A name="' . &FileEncode('s', $section) . '">' . 
				 "- in section " . &HTMLEncode($section) . "</A>";
			my $desc = &GetSectionDescriptionInBrakes($section);
			$capt .= ":" if $desc eq '';
			$desc = " ${desc}:" if $desc ne '';
					
			$tables{$letter} = &BeginTable(\*M, $capt, 4, $desc);
			$lastsections{$letter} = $section;
		}
		&AddToTable(\*M, $tables{$letter}, "<A href=\"$manurl$file\">$name</A>");
	}

	if ($lastletter ne '') {
		&EndTable(\*M, $tables{$lastletter});
		close M;
	}

	foreach my $letter ( keys( %$letters ) ) {
		open M, ">>$tgttmp/man/" . &FileEncode($type, $letter) . ".html";
		print M &TemplateFile($template_mbn_end, 
			 	    { 'TITLE' => $conf->{'DWWW_TITLE'},
				      'SECTIONS' => &GetIndex('s', $letters->{$letter})
				    });
		close M;
	}
}

# 
# Build lists of manual pages according to section
###
sub man_by_section() {
	my $type    = 's';
	my $section = undef;

	# Start a file for each section
	foreach $section ( keys( %$sections ) ) {
		open M, ">$tgttmp/man/" . &FileEncode($type, $section) . ".html";
		print M &TemplateFile($template_mbs_start, 
			 	    { 'TITLE' => $conf->{'DWWW_TITLE'},
				      'SECTION' => &HTMLEncode($section),
				      'SECTIONDESC' => &GetSectionDescriptionInBrakes($section),
				      'HREFSECTION' => &FileEncode($type, $section),
				      'LETTERS' => &GetIndex('n', $sections->{$section})
				    });
		close M;
	}

	my $table	 = undef;
	my $lastsection  = '';
	my $lastletter   = '';
	seek ($manlist_fh, 0, 0);

	while (<$manlist_fh>) {
		chomp();
		my ($section, $letter, $name, $file) = split ($sepr, $_, 4);
		# Note that records are sorted by section
		# and for each section - by the letter
		if ($lastsection ne $section) {
			if (defined $table) {
				&EndTable(\*M, $table);
				close M;
			}
			open M, ">>$tgttmp/man/" . &FileEncode($type, $section) . ".html";
			$lastsection = $section;
			$lastletter  = '';
			$table       = undef;
		}
		if ($lastletter ne $letter) {
			my $capt='<A name="' . &FileEncode('n', $letter) . '">' . 
				 "- starting with " . &HTMLEncode($letter) . ":</A>";

			if (defined $table) {
				&EndTable(\*M, $table);
			}
					
			$table      = &BeginTable(\*M, $capt, 4);
			$lastletter = $letter;
		}

		die ('Internal error: $table should be defined! ($file=' . $file .')')
			 unless (defined $table);

		&AddToTable(\*M, $table, "<A href=\"$manurl$file\">$name</A>");
	}

	if ($lastsection ne '') {
		if (defined $table) { 
			&EndTable(\*M, $table);
		}
		close M;
	}

	foreach $section ( keys( %$sections ) ) {
		open M, ">>$tgttmp/man/" . &FileEncode($type, $section) . ".html";
		print M &TemplateFile($template_mbs_end, 
			 	    { 'TITLE' => $conf->{'DWWW_TITLE'},
				      'LETTERS' => &GetIndex('n', $sections->{$section})
				    });
		close M;
	}

	
}

	
sub man_index() {


	open M, ">>$tgttmp/man/index.html";
	print M &TemplateFile($template_midx_start, 
		 	    { 'TITLE' => $conf->{'DWWW_TITLE'},
			    });
	
	my $table = &BeginTable(\*M, '<A name="n">Man pages by first letter:</A>', 8, '', [3,3,3,3,3,3,3,'*']);

	foreach my $letter ( sort keys( %$letters ) ) {
		my $fname =  &FileEncode('n', $letter);
		&AddToTable(\*M, $table, "<A name=\"$fname\" href=\"$fname.html\">"
					. &HTMLEncode($letter) . "</A>");
	}

	&EndTable(\*M, $table);

	print M "<BR><HR><BR>\n";

	$table = &BeginTable(\*M, '<A name="s">Man pages by section:</A>', 3, '', [4, 10, '*']);
	
	my $lastsectionbase = "";
	my $sectionbase = "";
	foreach my $section ( sort keys( %$sections ) ) {
		$sectionbase = substr($section, 0, 1);
		if ($sectionbase ne $lastsectionbase)
		{
			if ($lastsectionbase ne "") {
				# empty row separating sections
				&AddToTable(\*M, $table, '&nbsp;');
				&AddToTable(\*M, $table, '');
				&AddToTable(\*M, $table, '');
			}
			if ($sectionbase ne $section) {
				&AddToTable(\*M, $table, '<B>' . &HTMLEncode($sectionbase) . '</B>');
				&AddToTable(\*M, $table, '');
				&AddToTable(\*M, $table, '<B>' . &GetSectionDescription($sectionbase.'</B>'));
			}

			$lastsectionbase = $sectionbase;
		}

		my $desc      = &GetSectionDescription($section);
		my ($bs, $be) = undef;
		if ($sectionbase eq $section) {
			$bs = '<B>';
			$be = '</B>';
		} else {
			$bs = '';
			$be = '';
			$desc = '&nbsp;&nbsp;' . $desc unless $desc eq '';
			&AddToTable(\*M, $table, '');
		}

		my $fname = &FileEncode('s', $section);
		&AddToTable(\*M, $table, "<A name=\"$fname\" href=\"$fname.html\">"
					. $bs . &HTMLEncode($section) . $be . "</A>");

		&AddToTable(\*M, $table, '') if  ($sectionbase eq $section);

		&AddToTable(\*M, $table, $bs . $desc . $be);
	}
	&EndTable(\*M, $table);


	print M &TemplateFile($template_midx_end, 
		 	    { });
}

#
# Create the front page.
#
sub make_front_page() {
	open M, ">$tgttmp/index.html" or die "Cannot open file $tgttmp/index.html: $!";
	print M &TemplateFile($template_index_main, 
		 	    { 'TITLE' => $conf->{'DWWW_TITLE'},
			    });
	close M;
}


# This is a special routine for the wn webserver
#
sub make_wnindex
{
	my $dir = shift;
        
	chdir("$dir");
        if ( ! -e "index" ) {
		open I, ">index";
                print I "Attribute=serveall\n";
		close I;
	}
        
        &system("/usr/bin/wndex >/dev/null");
}

#########################################
# 
# MAIN PROGRAM
# 
#########################################

STDOUT->autoflush(1);

print "Building dwww pages (a-g):\n";

print "  a) list of manual pages... ";
&find_man();
print "done\n";

print "  b) list of sections and names... ";
&find_sections_and_letters();
print "done\n";

print "  c) manual pages by name... ";
&man_by_name();
print "done\n";

print "  d) manual pages by section... ";
&man_by_section();
print "done\n";

print "  e) manual pages index... ";
&man_index();
print "done\n";

print "  f) front page... ";
&make_front_page();
print "done\n";

print "  g) copying files... ";
system("cp -a $dwww_lib_dir/*.jpg \"$tgttmp/.\"");

# copying menu directory;
( -d "$tgt/menu" ) && system("cp -a \"$tgt/menu\" \"$tgttmp/\"");

rmtree("$tgt");
rename("$tgttmp", "$tgt") or die "Cannot rename $tgttmp to $tgt: $!";

print "done\n";
# 
# For wn, special handling is required:
if ( -x "/usr/bin/wndex" ) {
	&make_wnindex("$tgt");
	&make_wnindex("$tgt/man");
	&make_wnindex("$tgt/menu");
}

print "The dwww pages have been re-built.\n";

exit (0);
